LFR: THEORY
 BEGIN

 
  %-- light sensors
  LightSensorReading: TYPE = { x: nonneg_real | x <= 255 }
  LightSensors: TYPE = [#
    left: LightSensorReading,
    right: LightSensorReading
  #]
 

  %-- motor
  Speed: TYPE = { x: real | x >= -1 AND x <= 1 }
  MotorSpeed: TYPE = [#
    left: Speed,
    right: Speed
  #]
  
  
  %-- user interface state
  State: TYPE =
        [#  lightSensors: LightSensors,
            motorSpeed: MotorSpeed
	 #]

  init_state: State =
      (# lightSensors := (# left := 250, right := 0 #),
         motorSpeed := (# left := 0, right := 0 #)
       #)

  update_left_motor_speed(st: State): Speed =
   LET ls = lightSensors(st) IN
     COND ls`right < 150 AND ls`left < 150 -> 0.4,
          ls`right < 150 AND ls`left > 150 -> 0.5,
          ls`right > 150 AND ls`left < 150 -> 0.1
    ENDCOND

  update_right_motor_speed(st: State): Speed =
   LET ls = lightSensors(st) IN  
     COND ls`right < 150 AND ls`left < 150 -> -0.4,
          ls`right < 150 AND ls`left > 150 -> -0.1,
          ls`right > 150 AND ls`left < 150 -> -0.5
    ENDCOND

  tick(st: State): State =
      st WITH [motorSpeed
                   := (# left := update_left_motor_speed(st),
                         right := update_right_motor_speed(st)
		      #) 
              ]

			  
KTH_STEP(N:nat) : RECURSIVE State =
  IF N=0 THEN
		init_state
         ELSE
	     tick(KTH_STEP(N-1)) 
  ENDIF
 MEASURE N			  
			  
input_hypothesis(st:State): State =
	st WITH[lightSensors := (# left := st`lightSensors`left * 4 / 5, right := st`lightSensors`right + 40  #)]

  KTH_STEP_1(N:nat) : RECURSIVE State =
  IF N=0 THEN
		init_state
         ELSE
	     LET st_input = input_hypothesis(KTH_STEP(N-1)) IN
    		    tick(st_input) 
  ENDIF
 MEASURE N
 
 
 
 END LFR
